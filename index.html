<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>リアルタイム交通マップ (TomTom API)</title>
<link href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet">
<style>
  :root { color-scheme: light dark; }
  html, body, #map { height: 100%; margin: 0; }
  .topbar {
    position: absolute; inset: 8px 8px auto 8px; z-index: 1000;
    background: rgba(0,0,0,.65); color:#fff; padding:10px 12px; border-radius:12px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
    backdrop-filter: blur(6px);
  }
  .topbar h1 { font-size: 16px; margin: 0 0 6px; font-weight: 700; }
  .controls { display: grid; grid-template-columns: auto auto; gap: 6px 12px; align-items: center; }
  .legend { display:flex; gap:8px; margin-top:6px; align-items:center; flex-wrap:wrap; }
  .chip { width:18px; height:8px; border-radius: 4px; display:inline-block; }
  .chip.green{ background:#2ecc71;}
  .chip.orange{ background:#f1c40f;}
  .chip.red{ background:#e74c3c;}
  .leaflet-popup-content { font-family: system-ui, -apple-system, "Noto Sans JP", sans-serif; }
  .btn { cursor:pointer; padding:6px 10px; border-radius:10px; border:1px solid #fff3; background:#fff1; color:#fff; }
  .btn:active { transform: scale(0.98); }
  .status { font-size:12px; opacity:.9 }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  select, input[type="checkbox"] { cursor:pointer; }
  .error { color:#ffb3b3; font-size:12px; margin-top:4px; display:none; max-width: 420px; }
</style>
</head>
<body>
<div id="map"></div>

<div class="topbar">
  <h1>リアルタイム交通マップ</h1>
  <div class="controls">
    <div class="row">
      <label><input id="flowToggle" type="checkbox" checked> 渋滞レイヤ（Flow）</label>
      <label><input id="incToggle" type="checkbox" checked> 事故・工事（Incidents）</label>
    </div>
    <div class="row">
      <label>更新頻度:
        <select id="refreshSelect">
          <option value="15000">15秒</option>
          <option value="30000">30秒</option>
          <option value="60000" selected>60秒</option>
          <option value="120000">2分</option>
          <option value="300000">5分</option>
        </select>
      </label>
      <button id="refreshBtn" class="btn">今すぐ更新</button>
      <span class="status" id="lastUpdate">最終更新: —</span>
    </div>
    <div class="row">
      <button id="locateOnceBtn" class="btn">現在地へ移動</button>
      <label><input id="followMeToggle" type="checkbox"> 自位置を表示して追従</label>
    </div>
    <div id="helpErr" class="error"></div>
  </div>
  <div class="legend">
    <span class="chip green"></span>スムーズ
    <span class="chip orange"></span>やや混雑
    <span class="chip red"></span>渋滞
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const TOMTOM_API_KEY = '95nUvWfM7ARBG60JdI3I37jG8N9yU9M4';
const START_POS = [35.6812, 139.7671];
const START_ZOOM = 15; // さらに命中率UPのため初期ズームを上げる

const map = L.map('map', { zoomControl: true }).setView(START_POS, START_ZOOM);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution:'© OpenStreetMap'
}).addTo(map);

const FLOW_URL = `https://api.tomtom.com/traffic/map/4/tile/flow/relative0/{z}/{x}/{y}.png?tileSize=256&key=${TOMTOM_API_KEY}`;
const INC_URL  = `https://api.tomtom.com/traffic/map/4/tile/incidents/{z}/{x}/{y}.png?tileSize=256&key=${TOMTOM_API_KEY}`;
const flowTiles = L.tileLayer(FLOW_URL, { opacity: 0.9, zIndex: 500 }).addTo(map);
const incidentTiles = L.tileLayer(INC_URL, { opacity: 0.9, zIndex: 600 }).addTo(map);

document.getElementById('flowToggle').addEventListener('change', (e) => e.target.checked ? flowTiles.addTo(map) : map.removeLayer(flowTiles));
document.getElementById('incToggle').addEventListener('change', (e) => e.target.checked ? incidentTiles.addTo(map) : map.removeLayer(incidentTiles));

const lastUpdateEl = document.getElementById('lastUpdate');
const helpErrEl = document.getElementById('helpErr');
function setErr(msg) { helpErrEl.textContent = msg || ''; helpErrEl.style.display = msg ? 'block' : 'none'; }

function refreshTiles(){
  if (map.hasLayer(flowTiles))     flowTiles.redraw();
  if (map.hasLayer(incidentTiles)) incidentTiles.redraw();
  lastUpdateEl.textContent = '最終更新: ' + new Date().toLocaleTimeString();
}

const refreshSelect = document.getElementById('refreshSelect');
let refreshTimer = null;
function applyInterval() {
  if (refreshTimer) clearInterval(refreshTimer);
  const ms = parseInt(refreshSelect.value, 10);
  refreshTimer = setInterval(refreshTiles, ms);
}
document.getElementById('refreshBtn').onclick = refreshTiles;
refreshSelect.onchange = applyInterval;
refreshTiles();
applyInterval();
pingKey();

async function tryFlowAt(lat, lng, z){
  const styles = ['absolute','relative0'];
  for (const style of styles){
    const url = new URL(`https://api.tomtom.com/traffic/services/4/flowSegmentData/${style}/${z}/json`);
    url.searchParams.set('point', `${lat},${lng}`);
    url.searchParams.set('key', TOMTOM_API_KEY);
    const res = await fetch(url.toString());
    const text = await res.text();
    if (res.ok) return { ok:true, style, text };
    if (res.status !== 400) return { ok:false, style, text, status:res.status };
  }
  return { ok:false, text:'400 Bad Request', status:400 };
}

function* nearbyOffsetsMeters(){
  // 同心円 + 16方位（22.5°刻み）で最大 ~250m まで探索
  const radii = [0,15,30,50,75,100,150,200,250]; // meters
  for (const r of radii){
    const steps = 16; // 0..360°
    for (let i=0;i<steps;i++){
      const theta = (Math.PI * 2 * i) / steps; // ラジアン
      const dx = Math.cos(theta) * r;
      const dy = Math.sin(theta) * r;
      yield [dx, dy];
    }
  }
}
  }
}
function metersToDegrees(lat, dx, dy){
  const latDeg = dy / 110540;
  const lngDeg = dx / (111320 * Math.cos(lat * Math.PI/180));
  return [latDeg, lngDeg];
}

async function pingKey() {
  try {
    const z = Math.max(0, Math.min(22, Math.round(map.getZoom() || 14)));
    let lastErr = '';
    for (const [mx,my] of nearbyOffsetsMeters()){
      const [dlat, dlng] = metersToDegrees(START_POS[0], mx, my);
      const lat = START_POS[0] + dlat, lng = START_POS[1] + dlng;
      const r = await tryFlowAt(lat, lng, z);
      if (r.ok){ setErr(''); return; }
      lastErr = `TomTom API ${r.status ?? 400} — ${r.text}`;
    }
    setErr(lastErr || 'TomTom API 400 — Point too far from nearest existing segment.');
  } catch (e) {
    setErr('ネットワークに到達できません。HTTPS で開いているか / CORS / ネットワーク設定をご確認ください。');
  }
}

const locateOnceBtn = document.getElementById('locateOnceBtn');
const followMeToggle = document.getElementById('followMeToggle');
let watchId = null, meMarker = null, meCircle = null;
function updateMe(lat, lng, acc){
  const ll = [lat, lng];
  if (!meMarker) { meMarker = L.marker(ll, { title: 'あなたの現在地' }).addTo(map); }
  else { meMarker.setLatLng(ll); }
  if (!meCircle) { meCircle = L.circle(ll, { radius: acc || 30, color:'#4aa3ff', fillColor:'#4aa3ff', fillOpacity:0.15 }).addTo(map); }
  else { meCircle.setLatLng(ll).setRadius(acc || 30); }
}
locateOnceBtn.onclick = () => {
  if (!navigator.geolocation) return alert('位置情報に非対応');
  navigator.geolocation.getCurrentPosition(pos => {
    const { latitude, longitude, accuracy } = pos.coords;
    updateMe(latitude, longitude, accuracy);
    map.setView([latitude, longitude], 14);
  }, err => alert('現在地取得失敗: ' + err.message), { enableHighAccuracy:true, maximumAge:10000, timeout:10000 });
};
followMeToggle.addEventListener('change', () => {
  if (followMeToggle.checked) {
    if (!navigator.geolocation) { alert('位置情報に非対応'); followMeToggle.checked = false; return; }
    watchId = navigator.geolocation.watchPosition(pos => {
      const { latitude, longitude, accuracy } = pos.coords;
      updateMe(latitude, longitude, accuracy);
      map.setView([latitude, longitude], Math.max(map.getZoom(), 14));
    }, err => { alert('追従失敗: ' + err.message); followMeToggle.checked = false; }, { enableHighAccuracy:true, maximumAge:8000, timeout:10000 });
  } else { if (watchId !== null) { navigator.geolocation.clearWatch(watchId); watchId = null; } }
});

let busy = false;
map.on('click', async (e) => {
  if (busy) return; busy = true;
  let { lat, lng } = e.latlng;
  const z = Math.max(14, Math.min(22, Math.round(map.getZoom() || 16))); // 14以上を強制
  try {
    let success = null, usedLat = lat, usedLng = lng, usedStyle = 'absolute', lastText = '';
    for (const [mx,my] of nearbyOffsetsMeters()){
      const [dlat, dlng] = metersToDegrees(lat, mx, my);
      const r = await tryFlowAt(lat + dlat, lng + dlng, z);
      if (r.ok){ success = r; usedLat = lat + dlat; usedLng = lng + dlng; usedStyle = r.style; break; }
      lastText = r.text;
    }
    if (!success) throw new Error(`API 400 — ${lastText || 'Point too far from nearest existing segment.'}`);
    const data = JSON.parse(success.text);
    const f = data && data.flowSegmentData;
    if (!f) throw new Error('No segment data');
    const html = `<b>区間の交通状況</b> <small>(${usedStyle})</small><br>
      現在速度: <b>${f.currentSpeed} km/h</b><br>
      自由流速度: ${f.freeFlowSpeed} km/h<br>
      旅行時間(現在): ${Math.round(f.currentTravelTime)} 秒<br>
      旅行時間(自由流): ${Math.round(f.freeFlowTravelTime)} 秒<br>
      信頼度: ${(f.confidence*100).toFixed(0)}%`;
    L.popup().setLatLng([usedLat, usedLng]).setContent(html).openOn(map);
  } catch (err) {
    console.error(err);
    L.popup().setLatLng([lat, lng]).setContent('データ取得失敗。道路上で試すか、ズームを上げてください。<br><small>'+String(err)+'</small>').openOn(map);
  } finally { busy = false; }
});setLatLng([usedLat, usedLng]).setContent(html).openOn(map);
  } catch (err) {
    console.error(err);
    L.popup().setLatLng([lat, lng]).setContent('データ取得失敗<br><small>'+String(err)+'</small>').openOn(map);
  } finally { busy = false; }
});
</script>
</body>
</html>
